// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: order.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO order_groups (profile_id)
VALUES ($1) RETURNING id, profile_id, created_at, updated_at
`

func (q *Queries) CreateOrder(ctx context.Context, profileID string) (OrderGroup, error) {
	row := q.db.QueryRow(ctx, createOrder, profileID)
	var i OrderGroup
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, product_id, price, quantity, status_name, thumbnail_url)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, product_id, order_id, price, status_name, quantity, tracking_url, created_at, updated_at, tracking_number, tracking_service, thumbnail_url
`

type CreateOrderItemParams struct {
	OrderID      int32
	ProductID    int32
	Price        pgtype.Numeric
	Quantity     int32
	StatusName   pgtype.Text
	ThumbnailUrl pgtype.Text
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.Price,
		arg.Quantity,
		arg.StatusName,
		arg.ThumbnailUrl,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OrderID,
		&i.Price,
		&i.StatusName,
		&i.Quantity,
		&i.TrackingUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackingNumber,
		&i.TrackingService,
		&i.ThumbnailUrl,
	)
	return i, err
}

const createOrderWithStatus = `-- name: CreateOrderWithStatus :one
SELECT oi.id, oi.product_id, oi.order_id, oi.price, oi.status_name, oi.quantity, oi.tracking_url, oi.created_at, oi.updated_at, oi.tracking_number, oi.tracking_service, oi.thumbnail_url, os.status_name
FROM order_items oi
JOIN order_statuses os ON oi.status_id = os.id
WHERE oi.id = $1
`

type CreateOrderWithStatusRow struct {
	ID              int32
	ProductID       int32
	OrderID         int32
	Price           pgtype.Numeric
	StatusName      pgtype.Text
	Quantity        int32
	TrackingUrl     pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	TrackingNumber  pgtype.Text
	TrackingService pgtype.Text
	ThumbnailUrl    pgtype.Text
	StatusName_2    string
}

func (q *Queries) CreateOrderWithStatus(ctx context.Context, id int32) (CreateOrderWithStatusRow, error) {
	row := q.db.QueryRow(ctx, createOrderWithStatus, id)
	var i CreateOrderWithStatusRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OrderID,
		&i.Price,
		&i.StatusName,
		&i.Quantity,
		&i.TrackingUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackingNumber,
		&i.TrackingService,
		&i.ThumbnailUrl,
		&i.StatusName_2,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM order_groups
WHERE id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT id, profile_id, created_at, updated_at FROM order_groups
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, id int32) (OrderGroup, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i OrderGroup
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderItemStatuses = `-- name: GetOrderItemStatuses :many
SELECT oi.id, oi.status_name AS item_status, os.status_name AS order_status
FROM order_items oi
LEFT JOIN order_statuses os ON oi.order_id = os.order_id
WHERE oi.order_id = $1
`

type GetOrderItemStatusesRow struct {
	ID          int32
	ItemStatus  pgtype.Text
	OrderStatus pgtype.Text
}

func (q *Queries) GetOrderItemStatuses(ctx context.Context, orderID int32) ([]GetOrderItemStatusesRow, error) {
	rows, err := q.db.Query(ctx, getOrderItemStatuses, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemStatusesRow
	for rows.Next() {
		var i GetOrderItemStatusesRow
		if err := rows.Scan(&i.ID, &i.ItemStatus, &i.OrderStatus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT 
    oi.id, 
    oi.product_id, 
    oi.price, 
    oi.quantity, 
    oi.status_name, 
    oi.tracking_url, 
    oi.tracking_number, 
    oi.tracking_service, 
    oi.thumbnail_url AS order_item_thumbnail,
    p.title AS product_title,
    pi.image_url AS product_thumbnail_url
FROM
    order_items oi
LEFT JOIN
    products p ON oi.product_id = p.id
LEFT JOIN
    product_image_thumbnail pit ON p.id = pit.product_id
LEFT JOIN
    product_images pi ON pit.product_image_id = pi.id
WHERE 
    oi.order_id = $1
`

type GetOrderItemsRow struct {
	ID                  int32
	ProductID           int32
	Price               pgtype.Numeric
	Quantity            int32
	StatusName          pgtype.Text
	TrackingUrl         pgtype.Text
	TrackingNumber      pgtype.Text
	TrackingService     pgtype.Text
	OrderItemThumbnail  pgtype.Text
	ProductTitle        pgtype.Text
	ProductThumbnailUrl pgtype.Text
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID int32) ([]GetOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsRow
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Price,
			&i.Quantity,
			&i.StatusName,
			&i.TrackingUrl,
			&i.TrackingNumber,
			&i.TrackingService,
			&i.OrderItemThumbnail,
			&i.ProductTitle,
			&i.ProductThumbnailUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrders = `-- name: GetOrders :many
SELECT id, profile_id, created_at, updated_at FROM order_groups
ORDER BY id
`

func (q *Queries) GetOrders(ctx context.Context) ([]OrderGroup, error) {
	rows, err := q.db.Query(ctx, getOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderGroup
	for rows.Next() {
		var i OrderGroup
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSellerOrderItems = `-- name: GetSellerOrderItems :many
SELECT 
    oi.id,
    oi.product_id,
    oi.price,
    oi.quantity,
    oi.status_name,
    oi.tracking_url,
    oi.tracking_number,
    oi.tracking_service,
    oi.thumbnail_url
FROM
    order_items oi
JOIN
    products p ON oi.product_id = p.id
WHERE 
    oi.order_id = $1
    AND p.profile_id = $2
`

type GetSellerOrderItemsParams struct {
	OrderID   int32
	ProfileID pgtype.Text
}

type GetSellerOrderItemsRow struct {
	ID              int32
	ProductID       int32
	Price           pgtype.Numeric
	Quantity        int32
	StatusName      pgtype.Text
	TrackingUrl     pgtype.Text
	TrackingNumber  pgtype.Text
	TrackingService pgtype.Text
	ThumbnailUrl    pgtype.Text
}

func (q *Queries) GetSellerOrderItems(ctx context.Context, arg GetSellerOrderItemsParams) ([]GetSellerOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getSellerOrderItems, arg.OrderID, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSellerOrderItemsRow
	for rows.Next() {
		var i GetSellerOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Price,
			&i.Quantity,
			&i.StatusName,
			&i.TrackingUrl,
			&i.TrackingNumber,
			&i.TrackingService,
			&i.ThumbnailUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSellerOrders = `-- name: GetSellerOrders :many
SELECT DISTINCT
    og.id AS order_id,
    og.created_at AS order_created_at,
    og.updated_at AS order_updated_at,
    oi.status_name AS order_status,
    og.profile_id AS buyer_profile_id,
    oi.thumbnail_url
FROM 
    order_groups og
JOIN 
    order_items oi ON og.id = oi.order_id
JOIN 
    products p ON oi.product_id = p.id
WHERE 
    p.profile_id = $1  -- This is the seller's profile_id
ORDER BY 
    og.id DESC
`

type GetSellerOrdersRow struct {
	OrderID        int32
	OrderCreatedAt pgtype.Timestamp
	OrderUpdatedAt pgtype.Timestamp
	OrderStatus    pgtype.Text
	BuyerProfileID string
	ThumbnailUrl   pgtype.Text
}

func (q *Queries) GetSellerOrders(ctx context.Context, profileID pgtype.Text) ([]GetSellerOrdersRow, error) {
	rows, err := q.db.Query(ctx, getSellerOrders, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSellerOrdersRow
	for rows.Next() {
		var i GetSellerOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.OrderCreatedAt,
			&i.OrderUpdatedAt,
			&i.OrderStatus,
			&i.BuyerProfileID,
			&i.ThumbnailUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSellerOrdersCount = `-- name: GetSellerOrdersCount :one
SELECT COUNT(DISTINCT og.id) as total_orders
FROM order_groups og
JOIN order_items oi ON og.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE p.profile_id = $1 AND og.created_at >= $2 AND og.created_at < $3
`

type GetSellerOrdersCountParams struct {
	ProfileID   pgtype.Text
	CreatedAt   pgtype.Timestamp
	CreatedAt_2 pgtype.Timestamp
}

func (q *Queries) GetSellerOrdersCount(ctx context.Context, arg GetSellerOrdersCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getSellerOrdersCount, arg.ProfileID, arg.CreatedAt, arg.CreatedAt_2)
	var total_orders int64
	err := row.Scan(&total_orders)
	return total_orders, err
}

const getSellerProductsSold = `-- name: GetSellerProductsSold :one
SELECT COUNT(DISTINCT oi.id) as total_sold
FROM order_items oi
JOIN products p ON oi.product_id = p.id
WHERE p.profile_id = $1
`

func (q *Queries) GetSellerProductsSold(ctx context.Context, profileID pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getSellerProductsSold, profileID)
	var total_sold int64
	err := row.Scan(&total_sold)
	return total_sold, err
}

const getSellerStatsComprehensive = `-- name: GetSellerStatsComprehensive :one
WITH seller_stats AS (
    SELECT 
        COUNT(DISTINCT oi.id) as total_sold,
        COALESCE(SUM(oi.price * oi.quantity), 0) as total_revenue,
        COUNT(DISTINCT og.id) as total_orders
    FROM order_items oi
    JOIN products p ON oi.product_id = p.id
    JOIN order_groups og ON oi.order_id = og.id
    WHERE p.profile_id = $1 AND og.created_at >= $2 AND og.created_at < $3
),
top_products AS (
    SELECT p.id, p.title, COUNT(oi.id) as total_sold, SUM(oi.price * oi.quantity) as revenue
    FROM products p
    JOIN order_items oi ON p.id = oi.product_id
    JOIN order_groups og ON oi.order_id = og.id
    WHERE p.profile_id = $1 AND og.created_at >= $2 AND og.created_at < $3
    GROUP BY p.id, p.title
    ORDER BY total_sold DESC
    LIMIT 5
)
SELECT 
    (SELECT total_sold FROM seller_stats) as total_sold,
    (SELECT total_revenue FROM seller_stats) as total_revenue,
    (SELECT total_orders FROM seller_stats) as total_orders,
    json_agg(json_build_object(
        'id', tp.id,
        'title', tp.title,
        'totalSold', tp.total_sold,
        'revenue', tp.revenue
    )) as top_products
FROM top_products tp
`

type GetSellerStatsComprehensiveParams struct {
	ProfileID   pgtype.Text
	CreatedAt   pgtype.Timestamp
	CreatedAt_2 pgtype.Timestamp
}

type GetSellerStatsComprehensiveRow struct {
	TotalSold    int64
	TotalRevenue interface{}
	TotalOrders  int64
	TopProducts  []byte
}

func (q *Queries) GetSellerStatsComprehensive(ctx context.Context, arg GetSellerStatsComprehensiveParams) (GetSellerStatsComprehensiveRow, error) {
	row := q.db.QueryRow(ctx, getSellerStatsComprehensive, arg.ProfileID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetSellerStatsComprehensiveRow
	err := row.Scan(
		&i.TotalSold,
		&i.TotalRevenue,
		&i.TotalOrders,
		&i.TopProducts,
	)
	return i, err
}

const getSellerTopProducts = `-- name: GetSellerTopProducts :many
SELECT p.id, p.title, COUNT(oi.id) as total_sold, SUM(oi.price * oi.quantity) as revenue
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN order_groups og ON oi.order_id = og.id
WHERE p.profile_id = $1 AND og.created_at >= $2 AND og.created_at < $3
GROUP BY p.id, p.title
ORDER BY total_sold DESC
LIMIT $4
`

type GetSellerTopProductsParams struct {
	ProfileID   pgtype.Text
	CreatedAt   pgtype.Timestamp
	CreatedAt_2 pgtype.Timestamp
	Limit       int32
}

type GetSellerTopProductsRow struct {
	ID        int32
	Title     string
	TotalSold int64
	Revenue   int64
}

func (q *Queries) GetSellerTopProducts(ctx context.Context, arg GetSellerTopProductsParams) ([]GetSellerTopProductsRow, error) {
	rows, err := q.db.Query(ctx, getSellerTopProducts,
		arg.ProfileID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSellerTopProductsRow
	for rows.Next() {
		var i GetSellerTopProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TotalSold,
			&i.Revenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSellerTotalRevenue = `-- name: GetSellerTotalRevenue :one
SELECT COALESCE(SUM(oi.price * oi.quantity), 0) as total_revenue
FROM order_items oi
JOIN products p ON oi.product_id = p.id
JOIN order_groups og ON oi.order_id = og.id
WHERE p.profile_id = $1 AND og.created_at >= $2 AND og.created_at < $3
`

type GetSellerTotalRevenueParams struct {
	ProfileID   pgtype.Text
	CreatedAt   pgtype.Timestamp
	CreatedAt_2 pgtype.Timestamp
}

func (q *Queries) GetSellerTotalRevenue(ctx context.Context, arg GetSellerTotalRevenueParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getSellerTotalRevenue, arg.ProfileID, arg.CreatedAt, arg.CreatedAt_2)
	var total_revenue interface{}
	err := row.Scan(&total_revenue)
	return total_revenue, err
}

const getUserEvents = `-- name: GetUserEvents :many
SELECT id, profile_id, event_type, product_id, order_item_id, duration, occurred_at, additional_data FROM user_events
WHERE profile_id = $1
ORDER BY occurred_at DESC
LIMIT $2 OFFSET $3
`

type GetUserEventsParams struct {
	ProfileID pgtype.Text
	Limit     int32
	Offset    int32
}

func (q *Queries) GetUserEvents(ctx context.Context, arg GetUserEventsParams) ([]UserEvent, error) {
	rows, err := q.db.Query(ctx, getUserEvents, arg.ProfileID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEvent
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.EventType,
			&i.ProductID,
			&i.OrderItemID,
			&i.Duration,
			&i.OccurredAt,
			&i.AdditionalData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrders = `-- name: GetUserOrders :many
SELECT 
    og.id, og.profile_id, og.created_at, og.updated_at, 
    oi.thumbnail_url
FROM 
    order_groups og
JOIN 
    order_items oi ON og.id = oi.order_id
WHERE 
    og.profile_id = $1
GROUP BY 
    og.id, oi.thumbnail_url
ORDER BY 
    og.id DESC
`

type GetUserOrdersRow struct {
	ID           int32
	ProfileID    string
	CreatedAt    pgtype.Timestamp
	UpdatedAt    pgtype.Timestamp
	ThumbnailUrl pgtype.Text
}

func (q *Queries) GetUserOrders(ctx context.Context, profileID string) ([]GetUserOrdersRow, error) {
	rows, err := q.db.Query(ctx, getUserOrders, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserOrdersRow
	for rows.Next() {
		var i GetUserOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ThumbnailUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT 
    og.id, og.profile_id, og.created_at, og.updated_at, 
    oi.status_name AS order_status
FROM 
    order_groups og
JOIN 
    order_items oi ON og.id = oi.order_id
ORDER BY 
    og.id DESC
`

type ListOrdersRow struct {
	ID          int32
	ProfileID   string
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	OrderStatus pgtype.Text
}

func (q *Queries) ListOrders(ctx context.Context) ([]ListOrdersRow, error) {
	rows, err := q.db.Query(ctx, listOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersRow
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrderStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logUserEvent = `-- name: LogUserEvent :one
INSERT INTO user_events (profile_id, event_type, product_id, order_item_id, duration, additional_data)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, profile_id, event_type, product_id, order_item_id, duration, occurred_at, additional_data
`

type LogUserEventParams struct {
	ProfileID      pgtype.Text
	EventType      string
	ProductID      pgtype.Int4
	OrderItemID    pgtype.Int4
	Duration       pgtype.Int4
	AdditionalData []byte
}

func (q *Queries) LogUserEvent(ctx context.Context, arg LogUserEventParams) (UserEvent, error) {
	row := q.db.QueryRow(ctx, logUserEvent,
		arg.ProfileID,
		arg.EventType,
		arg.ProductID,
		arg.OrderItemID,
		arg.Duration,
		arg.AdditionalData,
	)
	var i UserEvent
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.EventType,
		&i.ProductID,
		&i.OrderItemID,
		&i.Duration,
		&i.OccurredAt,
		&i.AdditionalData,
	)
	return i, err
}

const updateOrderItemStatus = `-- name: UpdateOrderItemStatus :one
UPDATE order_items
SET status_name = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 RETURNING id, product_id, order_id, price, status_name, quantity, tracking_url, created_at, updated_at, tracking_number, tracking_service, thumbnail_url
`

type UpdateOrderItemStatusParams struct {
	ID         int32
	StatusName pgtype.Text
}

func (q *Queries) UpdateOrderItemStatus(ctx context.Context, arg UpdateOrderItemStatusParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, updateOrderItemStatus, arg.ID, arg.StatusName)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OrderID,
		&i.Price,
		&i.StatusName,
		&i.Quantity,
		&i.TrackingUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackingNumber,
		&i.TrackingService,
		&i.ThumbnailUrl,
	)
	return i, err
}
