// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: attribute.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCategoryAttribute = `-- name: CreateCategoryAttribute :one
INSERT INTO category_attributes (
    category_id, name, attribute_type_id, is_required, enum_values
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, category_id, name, attribute_type_id, is_required, enum_values
`

type CreateCategoryAttributeParams struct {
	CategoryID      pgtype.Int4
	Name            string
	AttributeTypeID pgtype.Int4
	IsRequired      pgtype.Bool
	EnumValues      []string
}

func (q *Queries) CreateCategoryAttribute(ctx context.Context, arg CreateCategoryAttributeParams) (CategoryAttribute, error) {
	row := q.db.QueryRow(ctx, createCategoryAttribute,
		arg.CategoryID,
		arg.Name,
		arg.AttributeTypeID,
		arg.IsRequired,
		arg.EnumValues,
	)
	var i CategoryAttribute
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.AttributeTypeID,
		&i.IsRequired,
		&i.EnumValues,
	)
	return i, err
}

const createProductAttributeValue = `-- name: CreateProductAttributeValue :one
INSERT INTO product_attribute_values (
    product_id, category_attribute_id, value_string, value_float, value_integer, value_boolean
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, product_id, category_attribute_id, value_string, value_float, value_integer, value_boolean
`

type CreateProductAttributeValueParams struct {
	ProductID           pgtype.Int4
	CategoryAttributeID pgtype.Int4
	ValueString         pgtype.Text
	ValueFloat          pgtype.Float8
	ValueInteger        pgtype.Int4
	ValueBoolean        pgtype.Bool
}

func (q *Queries) CreateProductAttributeValue(ctx context.Context, arg CreateProductAttributeValueParams) (ProductAttributeValue, error) {
	row := q.db.QueryRow(ctx, createProductAttributeValue,
		arg.ProductID,
		arg.CategoryAttributeID,
		arg.ValueString,
		arg.ValueFloat,
		arg.ValueInteger,
		arg.ValueBoolean,
	)
	var i ProductAttributeValue
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.CategoryAttributeID,
		&i.ValueString,
		&i.ValueFloat,
		&i.ValueInteger,
		&i.ValueBoolean,
	)
	return i, err
}

const getAttribute = `-- name: GetAttribute :one
SELECT id, category_id, name, attribute_type_id, is_required, enum_values FROM category_attributes 
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetAttribute(ctx context.Context, id int32) (CategoryAttribute, error) {
	row := q.db.QueryRow(ctx, getAttribute, id)
	var i CategoryAttribute
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.AttributeTypeID,
		&i.IsRequired,
		&i.EnumValues,
	)
	return i, err
}

const getCategoryAttributes = `-- name: GetCategoryAttributes :many
SELECT id, category_id, name, attribute_type_id, is_required, enum_values FROM category_attributes 
WHERE category_id = $1
`

func (q *Queries) GetCategoryAttributes(ctx context.Context, categoryID pgtype.Int4) ([]CategoryAttribute, error) {
	rows, err := q.db.Query(ctx, getCategoryAttributes, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CategoryAttribute
	for rows.Next() {
		var i CategoryAttribute
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.AttributeTypeID,
			&i.IsRequired,
			&i.EnumValues,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductAttributeValues = `-- name: GetProductAttributeValues :many
SELECT pav.id, pav.product_id, pav.category_attribute_id, pav.value_string, pav.value_float, pav.value_integer, pav.value_boolean, ca.name as attribute_name, at.name as attribute_type
FROM product_attribute_values pav
JOIN category_attributes ca ON pav.category_attribute_id = ca.id
JOIN attribute_types at ON ca.attribute_type_id = at.id
WHERE pav.product_id = $1
`

type GetProductAttributeValuesRow struct {
	ID                  int32
	ProductID           pgtype.Int4
	CategoryAttributeID pgtype.Int4
	ValueString         pgtype.Text
	ValueFloat          pgtype.Float8
	ValueInteger        pgtype.Int4
	ValueBoolean        pgtype.Bool
	AttributeName       string
	AttributeType       string
}

func (q *Queries) GetProductAttributeValues(ctx context.Context, productID pgtype.Int4) ([]GetProductAttributeValuesRow, error) {
	rows, err := q.db.Query(ctx, getProductAttributeValues, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductAttributeValuesRow
	for rows.Next() {
		var i GetProductAttributeValuesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.CategoryAttributeID,
			&i.ValueString,
			&i.ValueFloat,
			&i.ValueInteger,
			&i.ValueBoolean,
			&i.AttributeName,
			&i.AttributeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributes = `-- name: ListAttributes :many
SELECT id, name
FROM attribute_types
ORDER BY name
`

func (q *Queries) ListAttributes(ctx context.Context) ([]AttributeType, error) {
	rows, err := q.db.Query(ctx, listAttributes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AttributeType
	for rows.Next() {
		var i AttributeType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAttribute = `-- name: UpdateAttribute :exec
UPDATE category_attributes
SET  category_id = $1, name = $2, attribute_type_id = $3, is_required = $4, enum_values = $5, updated_at = CURRENT_TIMESTAMP
WHERE id = $6 RETURNING id, category_id, name, attribute_type_id, is_required, enum_values
`

type UpdateAttributeParams struct {
	CategoryID      pgtype.Int4
	Name            string
	AttributeTypeID pgtype.Int4
	IsRequired      pgtype.Bool
	EnumValues      []string
	ID              int32
}

func (q *Queries) UpdateAttribute(ctx context.Context, arg UpdateAttributeParams) error {
	_, err := q.db.Exec(ctx, updateAttribute,
		arg.CategoryID,
		arg.Name,
		arg.AttributeTypeID,
		arg.IsRequired,
		arg.EnumValues,
		arg.ID,
	)
	return err
}

const updateProductAttributeValue = `-- name: UpdateProductAttributeValue :exec
UPDATE product_attribute_values
SET product_id = $1, category_attribute_id = $2, value_string = $3, value_float = $4, value_integer = $5, value_boolean = $6
Where id = $7
`

type UpdateProductAttributeValueParams struct {
	ProductID           pgtype.Int4
	CategoryAttributeID pgtype.Int4
	ValueString         pgtype.Text
	ValueFloat          pgtype.Float8
	ValueInteger        pgtype.Int4
	ValueBoolean        pgtype.Bool
	ID                  int32
}

func (q *Queries) UpdateProductAttributeValue(ctx context.Context, arg UpdateProductAttributeValueParams) error {
	_, err := q.db.Exec(ctx, updateProductAttributeValue,
		arg.ProductID,
		arg.CategoryAttributeID,
		arg.ValueString,
		arg.ValueFloat,
		arg.ValueInteger,
		arg.ValueBoolean,
		arg.ID,
	)
	return err
}
